---
title: Integraci√≥n con Android
description: Esta gu√≠a describe el proceso detallado de integraci√≥n del SDK de EMMA en una aplicaci√≥n Android utilizando Kotlin y Android Studio en un entorno de desarrollo basado en Gradle sobre Windows 10.
---

## Requisitos previos

| **Componente**        | **Requerimiento**                                            |
|-----------------------|--------------------------------------------------------------|
| **Sistema Operativo** | Windows **10 o superior**                                        |
| **IDE**               | **Android Studio** (√∫ltima versi√≥n recomendada **2024.3.1**)         |  
| **Kotlin**            | Versi√≥n: **2.0.21**                                             |
| **Gradle**            | Versi√≥n: **8.11.1**                                             |
| **SDK EMMA**          | Versi√≥n: **4.15.5**                                             |

## [üì¶ Descargar APK](https://github.com/matiasc-emma/KotlinSDK/releases/download/v1.0.0/app-debug.apk)

## [üîß Repositorio ](https://github.com/matiasc-emma/KotlinSDK)

## Pasos para la Integraci√≥n del SDK de EMMA

<Steps>
  <Step 
  title="Incluir el Repositorio en tu Proyecto:
  ">

  Luego de crear el proyecto en tu IDE,  Abre el archivo **settings.gradle.kts**  (nivel del proyecto) ubicado en el directorio **Gradle Scripts**  y agrega la **URL** del repositorio de EMMA  `EMMA( maven { url = uri("https://repo.emma.io/emma") })` en la secci√≥n de **repositories**:

  ```kotlin title="settings.gradle.kts(:project Settings)"
  EMMA( maven { url = uri("https://repo.emma.io/emma") })
  ```

  ![Paso 1](/matias/images/paso1.png)
  </Step>

  <Step 
  title="A√±ade la dependencia en el archivo build.gradle.kts(:app).
  ">

 Escribe esta anotaci√≥n `implementation("io.emma:eMMaSDK:4.15.+")` , La versi√≥n m√°s reciente del SDK es la **4.15.5.** Consulta esta [p√°gina](https://developer.emma.io/es/android/sdk-upgrades) para detalles sobre las actualizaciones. 
  
  ```kotlin title="build.gradle.kts(:app)"
    implementation("io.emma:eMMaSDK:4.15.5")
  ```

  ![Paso 2](/matias/images/paso2.png)
  </Step>

  <Step 
  title="Obtener el Session Key de EMMA
  ">

  Para comenzar a utilizar EMMA, puedes guiarte con este [enlace:](https://docs.emma.io/es/home) y as√≠ [crear una cuenta;](https://ng.emma.io/es/register) Una vez registrada,  configura tu cuenta siguiendo los pasos indicados [aqu√≠](https://docs.emma.io/es/configuracion)  y luego solicita tus credenciales: la **EMMA Key** y la **API Key**, necesarias para habilitar la integraci√≥n,  aqu√≠  puedes ver la [gu√≠a.](https://docs.emma.io/es/configuracion#general-emma-key-y-api-key) 

  ![Paso 3](/matias/images/paso3.png)
  </Step>

   <Step 
  title="Permisos requeridos por el SDK
  ">
  El SDK contiene por defecto los siguientes permisos obligatorios. Estos permisos NO se tienen que a√±adir en el AndroidManifest.xml de la aplicaci√≥n, ya que es el mismo SDK quien los a√±ade:

  ![Paso 4](/matias/images/paso4.png)

  Si quieres habilitar la localizaci√≥n, tienes que a√±adir los siguientes permisos al **AndroidManifest.xml** de tu aplicaci√≥n:

    ```kotlin title="AndroidManifest.xml"
   <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
   <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
  ```
  
  ![Paso 5](/matias/images/paso5.png)

 </Step>

  <Step 
  title="Sincroniza tu proyecto 
  ">

  Al sincronizar Gradle, se actualizan dependencias, se configuran ajustes y se procesan los archivos build.gradle, permitiendo que la app se compile correctamente y sin errores.
   
  ![Paso 6](/matias/images/paso6.png)

  </Step>

  <Step 
  title="Inicializar la librer√≠a
  ">

  En tu clase Application, a√±ade lo siguiente:

  
    ```kotlin title="ExampleApplication.kts"
   import android.app.Application
import io.emma.android.EMMA

class ExampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        val configuration = EMMA.Configuration.Builder(this)
            .setSessionKey("TU_SESION_KEY")
            .trackScreenEvents(false)
            .setDebugActive(BuildConfig.DEBUG)
            .build()

        EMMA.getInstance().startSession(configuration)
    }
}
  ```
  <Warning>Recuerda habilitar esta funci√≥n en tu archivo **build.gradle.kts(:app)** .</Warning>

    ```kotlin title="build.gradle.kts(:app)"
    buildFeatures {
        buildConfig = true
    }
  ```
    ![Paso 8](/matias/images/paso8.png)

  <Error>Omitir este paso podr√≠a generar un error de la clase BuildConfig. </Error>

  ![Paso 7](/matias/images/paso7.png)

   <Warning>Para asegurarte de que tu clase **ExampleApplication** se ejecute correctamente al iniciar la aplicaci√≥n, debes registrarla en el archivo **AndroidManifest.xml** dentro de la etiqueta **application**. </Warning>

   ![Paso 9](/matias/images/paso9.png)

  </Step>

   <Step 
  title="Verificar en la plataforma de EMMA 
  ">

  Al configurar el SDK en la app, es importante verificar en la [plataforma de EMMA](https://ng.emma.io/es/login) (dashboard) que los usuarios est√©n siendo registrados como activos. Esto confirma que la integraci√≥n del SDK fue exitosa y que la app est√° enviando correctamente los eventos de inicio de sesi√≥n e instalaci√≥n.
   
  ![Paso 10](/matias/images/paso10.png)

  </Step>

</Steps>

## Desactivar env√≠o de pantallas

El env√≠o de pantallas est√° activo por defecto en el SDK de EMMA.Para desactivarlo usa la siguiente configuraci√≥n: `trackScreenEvents(false)`.


    ```kotlin title="ExampleApplication.kts"
   import android.app.Application
import io.emma.android.EMMA

class ExampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        val configuration = EMMA.Configuration.Builder(this)
            .setSessionKey("TU_SESION_KEY")
            .trackScreenEvents(false) // [!code focus]
            .setDebugActive(BuildConfig.DEBUG)
            .build()

        EMMA.getInstance().startSession(configuration)
    }
}
  ```

  ## Pol√≠tica de familias

Para todas aquellas apps que est√°n dentro del programa **Designed for Families** necesitan cumplir una serie de requisitos respecto a la informaci√≥n a compartir. Para ello EMMA ha habilitado una propiedad en el arranque de sesi√≥n para asegurar el cumplimiento de esta pol√≠tica.


    ```kotlin title="ExampleApplication.kts"
   import android.app.Application
import io.emma.android.EMMA

class ExampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        val configuration = EMMA.Configuration.Builder(this)
            .setSessionKey("TU_SESION_KEY")
            .setFamiliesPolicyTreatment(true) // [!code focus]
            .setDebugActive(BuildConfig.DEBUG)
            .build()

        EMMA.getInstance().startSession(configuration)
    }
}
  ```
Adem√°s, es importante deshabilitar el permiso para recolectar el Google Advertasing ID en el **AndroidManifest**.

    ```kotlin title="AndroidManifest.xml"
<uses-permission android:name="com.google.android.gms.permission.AD_ID"
 tools:node="remove"/>
  ```


## Proguard
Si utilizas **Proguard** o alguna alternativa compatible, a continuaci√≥n tenemos un ejemplo del contenido del fichero de reglas **proguard-rules.pro.** Puede que tengas que modificar otras reglas dependiendo de cada aplicaci√≥n.
    ```kotlin title="proguard-rules.pro"
# EMMA SDK
-keep class io.emma.android.** { *; }

# Rules for play services ads identifier
-keep class com.google.android.gms.common.ConnectionResult {
    int SUCCESS;
}
-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient {
    com.google.android.gms.ads.identifier.AdvertisingIdClient$Info getAdvertisingIdInfo(android.content.Context);
}
-keep class com.google.android.gms.ads.identifier.AdvertisingIdClient$Info {
    java.lang.String getId();
    boolean isLimitAdTrackingEnabled();
}

# Rule for google play referrer
-keep public class com.android.installreferrer.** { *; }

# Keep generic signatures; needed for correct type resolution
-keepattributes Signature

# Keep Gson annotations
-keepattributes RuntimeVisibleAnnotations,AnnotationDefault
-if class com.google.gson.reflect.TypeToken
-keep,allowobfuscation class com.google.gson.reflect.TypeToken
-keep,allowobfuscation class * extends com.google.gson.reflect.TypeToken
-keep,allowobfuscation,allowoptimization @com.google.gson.annotations.JsonAdapter class *
-keepclassmembers,allowobfuscation class * {
  @com.google.gson.annotations.Expose <fields>;
  @com.google.gson.annotations.JsonAdapter <fields>;
  @com.google.gson.annotations.Since <fields>;
  @com.google.gson.annotations.Until <fields>;
}

-keepclassmembers class * extends com.google.gson.TypeAdapter {
  <init>();
}
-keepclassmembers class * implements com.google.gson.TypeAdapterFactory {
  <init>();
}
-keepclassmembers class * implements com.google.gson.JsonSerializer {
  <init>();
}
-keepclassmembers class * implements com.google.gson.JsonDeserializer {
  <init>();
}

-if class *
-keepclasseswithmembers,allowobfuscation class <1> {
  @com.google.gson.annotations.SerializedName <fields>;
}
-if class * {
  @com.google.gson.annotations.SerializedName <fields>;
}
-keepclassmembers,allowobfuscation,allowoptimization class <1> {
  <init>();
}

# Rules for retrofit2
-keepattributes Signature, InnerClasses, EnclosingMethod
-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations
-keepattributes AnnotationDefault
-keepclassmembers,allowshrinking,allowobfuscation interface * {
    @retrofit2.http.* <methods>;
}
-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-dontwarn javax.annotation.**
-dontwarn kotlin.Unit
-dontwarn retrofit2.KotlinExtensions
-dontwarn retrofit2.KotlinExtensions$*
-if interface * { @retrofit2.http.* <methods>; }
-keep,allowobfuscation interface <1>

-if interface * { @retrofit2.http.* <methods>; }
-keep,allowobfuscation interface * extends <1>

-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation
-if interface * { @retrofit2.http.* public *** *(...); }
-keep,allowoptimization,allowshrinking,allowobfuscation class <3>

-keep,allowobfuscation,allowshrinking class retrofit2.Response

# Rules for okhttp3
-keepattributes Signature
-keepattributes Annotation
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }
-dontwarn okhttp3.**
-dontwarn okio.**

# Rules for glide (used to display images by sdk)
-keep class com.bumptech.glide.** { *; }
-dontwarn com.bumptech.glide.**

# Rules for push
-keep class com.google.firebase.** { *; }

# Rules for Huawei hms push and odid identifier
-ignorewarnings
-keepattributes *Annotation*
-keepattributes Exceptions
-keepattributes InnerClasses
-keepattributes Signature
-keepattributes SourceFile,LineNumberTable
-keep class com.huawei.hianalytics.**{*;}
-keep class com.huawei.updatesdk.**{*;}
-keep class com.huawei.hms.**{*;}

# Rules for Huawei ads-identifier and ads referrer
-keep class com.huawei.hms.ads.** { *; }
-keep interface com.huawei.hms.ads.** { *; }
  ```

<Info>Aseg√∫rate de tener habilitada la minificaci√≥n y configurado el archivo de reglas</Info>

    ```kotlin title="build.gradle.kts(app)"
android {
    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}

  ```

Luego utiliza este comando en tu terminal  `./gradlew assembleRelease` para que Proguard compile y ofusque el c√≥digo con las reglas descritas en el paso anterior 
    ```Bash title="Bash"
./gradlew assembleRelease
  ```

Verifica que haya compilado correctamente, debe aparecer un mensaje similar a esto:

![Proguard](/matias/images/proguard.png)

<Warning> Desde Android Gradle Plugin (AGP) 3.4+, R8 reemplaz√≥ a ProGuard por defecto. </Warning>

## Integraci√≥n Notificaciones Push

EMMA ofrece un completo sistema de env√≠o y reporting de Notificaciones Push f√°cil de integrar usando Firebase Cloud Messaging (FCM) en Android.

<Steps>
 <Step 
  title="Obtener Sender ID, Server Key y generar certificado SHA
  ">

Obt√©n en primer lugar tu propio **Sender ID** y **Server Key** para FCM como se espec√≠fica en este [art√≠culo.](https://docs.emma.io/es/comunicacion/mensajes-out-app/push-notifications#creaci%C3%B3n-del-proyecto-en-firebase-y-obtenci%C3%B3n-del-certficado)

Debes considerar al configurar el proyecto en Firebase generar las **Huellas digitales del  certificado SHA** con el siguiente comando `./gradlew signingReport` dentro de tu proyecto de Kotlin, usando la terminal.

 ```Js title="Bash"
     ./gradlew signingReport
  ```

  ![SHA](/matias/images/sha.png)

  </Step>

 <Step 
  title="Generar clave privada JSON 
  ">

Genera un archivo **JSON** de **clave privada**  entrando en la **configuraci√≥n** de tu proyecto de Firebase , **Cuentas de servicio**, y generar **nueva clave privada**.


  ![Clave privada](/matias/images/clave-privada.png)

  </Step>

 <Step 
  title="Configurar la plataforma EMMA
  ">

Adem√°s debes configurar la plataforma EMMA con ese **archivo JSON** de la siguiente manera; Entra al menu del **borde superior** y accede a **preferencias app**, has click en **Selecciona un fichero JSON**.  


  ![Clave privada json](/matias/images/json.png)

  </Step>

 <Step 
  title="Integrar FCM en tu Service
  ">

 Hay que a√±adir el siguiente service al **AndroidManifest.xml**: 


    ```kotlin title="AndroidManifest.xml"
<service
    android:name="io.emma.android.push.EMMAFcmMessagingService"
    android:enabled="true"
    android:exported="false">
    <intent-filter>
    <action android:name="com.google.firebase.MESSAGING_EVENT"/>
    </intent-filter>
</service>
  ```


  ![Service push](/matias/images/push.png)

  </Step>

  <Step 
  title="Configurar dependencias de Google Services nivel proyect
  ">

  Agrega el complemento de Google Services como dependencia en el archivo de Gradle build.gradle.kts a nivel de proyecto: [Aqu√≠](https://firebase.google.com/docs/android/setup?hl=es&authuser=0&_gl=1*cwj5ie*_ga*MzY1NTAyNTYwLjE3MzgyODU5NjU.*_ga_CW55HF8NVT*MTc0NDI3NjkxOS4zMi4xLjE3NDQyNzY5NTAuMjkuMC4w)  m√°s informaci√≥n sobre integraci√≥n de Firebase 

    ```kotlin title="settings.gradle.kts(:project)"
  
 id("com.google.gms.google-services") version "4.3.10" apply false
  ```

  ![Firebase](/matias/images/firebase.png)

  </Step>

    <Step 
  title="Configurar dependencias de Google Services nivel app
  ">
 Agrega el complemento de los servicios de Google en el archivo de Gradle **build.gradle.kts** a nivel de app.

    ```kotlin title="settings.gradle.kts(:app)"
  
 id("com.google.gms.google-services")
  ```
  Agrega los SDK de Firebase a tu app en el archivo Gradle build.gradle.kts a nivel de app, agrega las dependencias de los productos de Firebase que quieras usar en tu app. Es recomendable que uses la Firebase Android BoM para controlar las versiones de las bibliotecas.

    ```kotlin title="settings.gradle.kts(:app)"
  implementation(platform("com.google.firebase:firebase-bom:33.12.0"))
  ```

  ![Firebase App](/matias/images/firebase-app.png)

  </Step>

    <Step 
  title="Iniciando el sistema de push
  ">

  Inicia el sistema de push debajo del inicio de sesi√≥n en Application, esta anotaci√≥n usa un icono por defecto se puede personalizar. Debes anotar el siguiente c√≥digo:

    ```kotlin title="package com.example.integrationkotlin"
   import android.app.Application
import io.emma.android.EMMA

class ExampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        val configuration = EMMA.Configuration.Builder(this)
            .setSessionKey("TU_SESION_KEY")
            .trackScreenEvents(false)
            .setDebugActive(BuildConfig.DEBUG)
            .build()
        
        val pushOpt =          EMMAPushOptions.Builder(MainActivity::class.java,android.R.drawable.ic_dialog_info)// [!code focus]
            .setNotificationColor(android.graphics.Color.BLUE)// [!code focus]
            .setNotificationChannelName("Notificaciones")// [!code focus]
            .build()// [!code focus]

        EMMA.getInstance().startSession(configuration)
        EMMA.getInstance().startPushSystem(pushOpt)// [!code focus]
    }
}
  ```
<Info>
  Desde Android 13, para recibir notificaciones es necesario solicitar un permiso al  usuario. Para ello, EMMA ha a√±adido un m√©todo al SDK disponible en la versi√≥n 4.12 o superiores. (En mi caso uso API 29), por lo tanto, no lo implementar√©, este m√©todo tiene que ser llamado en un Activity.
</Info>

  </Step>

    <Step 
  title="A√±adir el m√©todo onNewIntent() 
  ">
 A√±adir el m√©todo onNewIntent() llamando a EMMA.onNewNotification(), que verificar√° si el usuario ha recibido una notificaci√≥n cuando la app est√° abierta.
  ```kotlin title="Kotlin"
 override fun onNewIntent(intent: Intent) {
    super.onNewIntent(intent);
    EMMA.getInstance().onNewNotification(intent,false);
}
  ```

<Warning> Modifica tu archivo  y a√±ade las l√≠neas anteriores, en la documentaci√≥n oficial la anotaci√≥n this hace referencia al contexto , en este caso particular la apps ya a√±ade contexto y se quita esa anotaci√≥n adem√°s no a√±ado una url por lo tanto en vez de true que verifica esto qued√≥ en false.</Warning>

  </Step>

</Steps>

## Integraci√≥n Behavior

Con EMMA puedes conocer la localizaci√≥n de tus usuarios, c√≥mo se registran en tu App, cu√°ntas transacciones realizan y hasta sus caracter√≠sticas propias. Es decir, toda la informaci√≥n de tus usuarios que obtendr√°s en la secci√≥n de Behavior.

#### Medici√≥n de eventos

La plataforma de EMMA hace la diferenciaci√≥n entre dos tipos de eventos: los que la plataforma incluye por defecto y los eventos personalizados (custom) que puedes integrar seg√∫n la estructura de tu aplicaci√≥n.

#### Eventos por defecto

Puedes consultar m√°s informaci√≥n sobre los eventos por defecto [aqu√≠](https://docs.emma.io/es/primeros-pasos/eventos#eventos-por-defecto)

<Warning>
Es importante destacar que, aunque la integraci√≥n est√© funcionando correctamente, se debe prestar atenci√≥n al tipo de dato que se maneja en cada uno de los m√©todos, especialmente en valores como **Double**, **String**, o estructuras como **MapString**, ya que un tipo incorrecto puede provocar errores en tiempo de ejecuci√≥n o datos mal registrados en la plataforma de EMMA.
</Warning>

<Steps>
  <Step title="Medir Registro">
    El m√©todo `EMMA.getInstance().registerUser()` permite enviar informaci√≥n sobre los registros en la aplicaci√≥n.

    ```kotlin title="Kotlin"
    fun register() {
        EMMA.getInstance().registerUser("554234", "test@emma.io")
    }
    ```
  </Step>

  <Step title="Medir transacciones">
    EMMA permite medir cualquier transacci√≥n o compra que se realice en tu app. Este es el ejemplo para medir una transacci√≥n:

    ```kotlin title="Kotlin"
    fun trackTransaction() {
        EMMA.getInstance().startOrder("<ORDER_ID>", "<CUSTOMER_ID>", 10.0, "")
        EMMA.getInstance().addProduct("<PRODUCT_ID>", "<PRODUCT_NAME>", 1.0, 10.0)
        EMMA.getInstance().trackOrder()
    }
    ```
  </Step>

  <Step title="Iniciar transacci√≥n">
    El m√©todo para iniciar la transacci√≥n es `EMMA.getInstance().startOrder()`.

    ```kotlin title="Kotlin"
    EMMA.getInstance().startOrder("<ORDER_ID>", "<CUSTOMER_ID>", 10.0, "")
    ```
  </Step>

  <Step title="A√±adir Productos a la transacci√≥n">
    Una vez iniciada la transacci√≥n, hay que a√±adir los productos a la misma. Para ello usaremos el m√©todo `EMMA.getInstance().addProduct()`.

    ```kotlin title="Kotlin"
    EMMA.getInstance().addProduct("<PRODUCT_ID>", "<PRODUCT_NAME>", 1.0, 10.0)
    ```
  </Step>

  <Step title="Medici√≥n de la transacci√≥n">
    Una vez tenemos todos los productos a√±adidos, ejecutamos la medici√≥n de la transacci√≥n con el m√©todo `EMMA.getInstance().trackOrder()`.

    ```kotlin title="Kotlin"
    EMMA.getInstance().trackOrder()
    ```
  </Step>

  <Step title="Cancelar una transacci√≥n">
    En el caso de que se necesite cancelar el tracking de una transacci√≥n, usaremos el m√©todo `EMMA.getInstance().cancelOrder()`.

    ```kotlin title="Kotlin"
    fun cancelTransaction() {
        EMMA.getInstance().cancelOrder("<ORDER_ID>")
    }
    ```
  </Step>

  <Step title="Eventos personalizados">

    Este evento fue implementado siguiendo la arquitectura por capas de la app, lo que permite mantener una separaci√≥n clara entre la l√≥gica de presentaci√≥n (UI), el dominio y el acceso al SDK (data).

  </Step>
    <Step 
  title="MainActivity.kt
  ">
 
  Este bot√≥n dispara el evento personalizado desde la UI.


  ![img custom](/matias/images/custom1.png)

  </Step>

    <Step 
  title="UI ‚Äì BehaviorViewModel.kt
  ">
Encapsula la l√≥gica del evento personalizado para ser reutilizada f√°cilmente.


  ![img custom](/matias/images/custom2.png)

  </Step>

      <Step 
  title="Dominio ‚Äì BehaviorTracker.kt
  ">
Define el contrato que implementar√° la capa de datos.


  ![img custom](/matias/images/custom3.png)

  </Step>

        <Step 
  title="Data ‚Äì BehaviorTrackerImpl.kt
  ">
Aqu√≠ es donde se construye el EMMAEventRequest, se agregan los atributos y finalmente se env√≠a el evento al SDK.


  ![img custom](/matias/images/custom4.png)

  </Step>

<Info>
La documentaci√≥n oficial da como ejemplo el siguiente m√©todo:
Puedes consultar m√°s informaci√≥n sobre los eventos personalizados [aqu√≠.](https://docs.emma.io/es/primeros-pasos/eventos#eventos-personalizados)
</Info>

```kotlin title="Kotlin"
val eventRequest = EMMAEventRequest("f983d4bef8fc44dad43a1bb30dde9e3c")
//Optional: custom attributes
eventRequest.attributes = attributes
//Optional: request status listener
eventRequest.requestListener = requestListener
//Optional: cumtom id for request delegate
eventRequest.customId = customId

EMMA.getInstance().trackEvent(eventRequest)
```

  <Step 
  title="Identificador de EMMA
  ">
Podemos recuperar el identificador interno de EMMA con el m√©todo `getUserID()`:

```kotlin title="Kotlin"
class MainActivity : BaseActivity(), EMMAUserInfoInterface {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        EMMA.getInstance().getUserID()
    }

    override fun OnGetUserInfo(userInfo: JSONObject?) {
      // Not implemented
    }

    override fun OnGetUserID(id: Int) {
            Log.d("MainActivity", id.toString())
    }
}
```
  </Step>

   <Step 
  title="Identificador de dispositivo
  ">
El formato del identificador es del tipo UUID V4. Para obtener el identificador del dispositivo usa el siguiente m√©todo:

```kotlin title="Kotlin"
EMMA.getInstance().getDeviceId()
```
  </Step>

   <Step 
  title="Identificador de usuario del cliente (Customer ID)
  ">
Para enviar el customer ID independientemente del login/registro usa el siguiente m√©todo:

```kotlin title="Kotlin"
EMMA.getInstance().setCustomerId("<Customer ID>")
```
  </Step>

   <Step 
  title="Configuraci√≥n del idioma del usuario
  ">
Establece manualmente el idioma preferido del usuario.
Este m√©todo permite sobrescribir el idioma predeterminado del dispositivo para establecer un idioma personalizado que se utilizar√° en todas las peticiones del SDK. Esto resulta √∫til en aplicaciones que permiten al usuario seleccionar un idioma diferente al configurado en el dispositivo.
Se debe usar el c√≥digo de idioma en formato ISO 639-1: 

```kotlin title="Kotlin"
// En este caso, establece ingl√©s como idioma
EMMA.getInstance().setUserLanguage("en")
```
<Info>Si no se llama a este m√©todo, EMMA utilizar√° por defecto el idioma preferido del usuario configurado en el sistema del dispositivo.</Info>
  </Step>

   <Step 
  title="Perfil del usuario (User Info)
  ">
Si necesitamos recuperar el perfil del usuario desde la aplicaci√≥n usaremos el m√©todo `getUserInfo()`:


```kotlin title="Kotlin"
class MainActivity : BaseActivity(), EMMAUserInfoInterface {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        EMMA.getInstance().getUserInfo()
    }

    override fun OnGetUserInfo(userInfo: JSONObject?) {
      userInfo?.let {
        // Do something with userInfo
      }
    }

    override fun OnGetUserID(id: Int) {
            // Not implemented
    }
}
```
  </Step>

   <Step 
  title="Informaci√≥n de la atribuci√≥n de la instalaci√≥n
  ">
Despu√©s del proceso de atribuci√≥n, EMMA pone a disposici√≥n del SDK la informaci√≥n de atribuci√≥n del usuario.

Para obtener la informaci√≥n de atribuci√≥n usaremos el m√©todo `getInstallAttributionInfo`:

```kotlin title="Kotlin"
class MainActivity : BaseActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

         EMMA.getInstance().getInstallAttributionInfo { attribution ->
            if (attribution != null) {
               // Do something with attribution
            }
        }
    }
}
```
  </Step>

</Steps>



## Integraci√≥n In-App Messaging

EMMA incluye 7 formatos comunicativos diferentes que puedes integrar para impactar a tus usuarios en Android:

- [NativeAd](https://docs.emma.io/es/mensajes-inapp#native-ad) - Formato que integra tus comunicaciones respetando siempre el formato y estilo de los contenidos de la App.

- [StartView](https://docs.emma.io/es/mensajes-inapp#startview) - Formato que se despliega en toda la pantalla mostrando contenido web.

- [AdBall](https://docs.emma.io/es/mensajes-inapp#adball) - Formato comunicativo con forma de burbuja, cuyo click provoca el despliegue de un contenido web.

- [Banner](https://docs.emma.io/es/mensajes-inapp#banner) - Formato b√°sico para tus comunicaciones que puedes utilizar para comunicar mensajes espec√≠ficos tanto arriba como abajo de la pantalla.

- [Strip](https://docs.emma.io/es/mensajes-inapp#strip) - Formato comunicativo que ocupa la barra de notificaciones del dispositivo y que muestra un mensaje de derecha a izquierda.

- [Coupon](https://docs.emma.io/es/mensajes-inapp#cup√≥n) - Formato que te da la opci√≥n de canjear cupones si tienes un lugar f√≠sico controlando el n√∫mero de redenciones, el c√≥digo promocional y la fecha de activaci√≥n y finalizaci√≥n.

## NativeAd

EMMA NativeAd te permite obtener la informaci√≥n de un NativeAd correspondiente a una plantilla que se haya definido y configurado en la plataforma de EMMA.

<Steps>

  <Step 
  title="Data - NativeAdDataSource.kt
  ">

Esta clase implementa la fuente de datos para anuncios nativos. Forma parte de la **capa de datos** de la arquitectura y encapsula por completo las interacciones con el SDK.Ofrece dos m√©todos p√∫blicos para obtener anuncios; **getNativeAd(...)** para solicitar un anuncio individual y **getNativeAdBatch(...)** para solicitar un lote (batch) de anuncios.

```kotlin title="NativeAdDataSource.kt"
class NativeAdDataSource : NativeAdDataSourceInterface,
    EMMAInAppMessageInterface,
    EMMABatchNativeAdInterface,
    EMMANativeAdInterface {

    private var singleAdCallback: ((EMMANativeAd) -> Unit)? = null
    private var batchAdCallback: ((List<EMMANativeAd>) -> Unit)? = null

    override fun getNativeAd(templateId: String, callback: (EMMANativeAd) -> Unit) {
        singleAdCallback = callback
        val request = EMMANativeAdRequest().apply {
            this.templateId = templateId
        }
        EMMA.getInstance().getInAppMessage(request, this)
    }

    override fun getNativeAdBatch(templateId: String, callback: (List<EMMANativeAd>) -> Unit) {
        batchAdCallback = callback
        val request = EMMANativeAdRequest().apply {
            this.templateId = templateId
            this.isBatch = true
        }
        EMMA.getInstance().getInAppMessage(request, this)
    }

    override fun onReceived(nativeAd: EMMANativeAd) {
        Log.d("NativeAd", "NativeAd recibido: ${nativeAd.nativeAdContent["Title"]?.fieldValue}")
        EMMA.getInstance().sendInAppImpression(CommunicationTypes.NATIVE_AD, nativeAd)
        singleAdCallback?.invoke(nativeAd)
    }

    override fun onBatchReceived(nativeAds: MutableList<EMMANativeAd>) {
        Log.d("NativeAd", "Batch recibido con ${nativeAds.size} anuncios.")
        nativeAds.forEach {
            EMMA.getInstance().sendInAppImpression(CommunicationTypes.NATIVE_AD, it)
        }
        batchAdCallback?.invoke(nativeAds)
    }

    override fun onShown(campaign: EMMACampaign?) {
        Log.d("NativeAd", "NativeAd mostrado.")
    }

    override fun onHide(campaign: EMMACampaign?) {
        Log.d("NativeAd", "NativeAd ocultado.")
    }

    override fun onClose(campaign: EMMACampaign?) {
        Log.d("NativeAd", "NativeAd cerrado.")
    }
}
```
<Info>[Aqu√≠](https://developer.emma.io/es/android/integracion-sdk#nativead) el ejemplo de la documentaci√≥n oficial</Info>

  </Step>

   <Step 
  title="Interface ‚Äì NativeAdRepository.kt
  ">

  Crear interface que act√∫e como puente entre la UI/ViewModel y la capa de datos (NativeAdDataSource)

  ```kotlin title="NativeAdDataSourceInterface.kt"
interface NativeAdDataSourceInterface {
    fun getNativeAd(templateId: String, callback: (EMMANativeAd) -> Unit)
    fun getNativeAdBatch(templateId: String, callback: (List<EMMANativeAd>) -> Unit)
}
```
  </Step>

  <Step 
  title="Repositorio ‚Äì NativeAdRepository.kt
  ">

  Delega el acceso a los datos al dataSource (que implementa la interfaz).

  ```kotlin title="NativeAdRepository.kt"
class NativeAdRepository(
    private val dataSource: NativeAdDataSourceInterface
) {
    fun getNativeAd(templateId: String, callback: (EMMANativeAd) -> Unit) {
        dataSource.getNativeAd(templateId, callback)
    }

    fun getNativeAdBatch(templateId: String, callback: (List<EMMANativeAd>) -> Unit) {
        dataSource.getNativeAdBatch(templateId, callback)
    }
}
```
  </Step>

 <Step 
  title="UI ‚Äì NativeAdManager.kt
  ">

Esta clase encapsula la l√≥gica de carga, renderizado y tracking de anuncios nativos utilizando el SDK de EMMA. Act√∫a como intermediario entre la capa de dominio (repositorio) y la interfaz de usuario.

  ```kotlin title="NativeAdManager.kt"
class NativeAdManager(
  private val context: Context,private val container: RelativeLayout) {

    private val repository = NativeAdRepository(NativeAdDataSource())

    fun loadNativeAd( templateId: String,onAdLoaded: ((EMMANativeAd) -> Unit)? = null,onNoCampaigns: (() -> Unit)? = null) {  
    }
    fun loadNativeAdBatch(templateId: String,onNoCampaigns: (() -> Unit)? = null) {
    }
    private fun renderNativeAd(nativeAd: EMMANativeAd) {
    }
    private fun renderContent( view: View,title: String,body: String,imageUrl: String?,ctaText: String,nativeAd:EMMANativeAd) {
    }
    private fun openNativeAd(nativeAd: EMMANativeAd) {
    }
    private fun trackImpression(nativeAd: EMMANativeAd) {
    }
    fun trackClick(nativeAd: EMMANativeAd) {
    }
}

```
  </Step>

  <Step 
  title="Manejo de anuncio √∫nico
  ">

Este m√©todo solicita un anuncio nativo individual desde el repositorio. Si no hay campa√±as activas (contenido vac√≠o), dispara el callback **onNoCampaigns**. 

  ```kotlin title="NativeAdManager.kt"
fun loadNativeAd(
    templateId: String,
    onAdLoaded: ((EMMANativeAd) -> Unit)? = null,
    onNoCampaigns: (() -> Unit)? = null
) {
    repository.getNativeAd(templateId) { nativeAd ->
        if (nativeAd.nativeAdContent.isEmpty()) {
            onNoCampaigns?.invoke()
            return@getNativeAd
        }

        renderNativeAd(nativeAd)
        onAdLoaded?.invoke(nativeAd)
    }
}

```
  </Step>

  <Step 
  title="Manejo de multiples anuncios 
  ">

Permite cargar m√∫ltiples anuncios nativos de forma simult√°nea **(modo batch)** y los renderiza en el contenedor de la UI.

  ```kotlin title="NativeAdManager.kt"
fun loadNativeAdBatch(
    templateId: String,
    onNoCampaigns: (() -> Unit)? = null
) {
    repository.getNativeAdBatch(templateId) { ads ->
        container.removeAllViews()
        if (ads.isEmpty()) {
            onNoCampaigns?.invoke()
            return@getNativeAdBatch
        }

        ads.forEach { ad -> renderNativeAd(ad) }
    }
}

```
  </Step>
    <Step 
  title="Renderizado de anuncio
  ">

Este m√©todo convierte los datos del anuncio en una vista visible dentro del RelativeLayout. Utiliza Glide para cargar im√°genes y asigna valores a los campos de texto.

  ```kotlin title="NativeAdManager.kt"
private fun renderNativeAd(nativeAd: EMMANativeAd) {
    val view = LayoutInflater.from(context).inflate(R.layout.view_native_ad, container, false)
    val content = nativeAd.nativeAdContent
    val containerField = content["container"]

    containerField?.fieldContainer?.forEach { side -> 
        renderContent(view, side["Title"]?.fieldValue ?: "", ...)
    } ?: run {
        renderContent(view, content["Title"]?.fieldValue ?: "", ...)
    }

    container.addView(view)
    trackImpression(nativeAd)
}

```
  </Step>

    <Step 
  title="Registro de impresi√≥n y clics
  ">
Estos m√©todos notifican al SDK que un anuncio fue visto o clickeado, utilizando los m√©todos oficiales **sendInAppImpression** y **sendInAppClick**.
  ```kotlin title="NativeAdManager.kt"
private fun trackImpression(nativeAd: EMMANativeAd) {
    EMMA.getInstance().sendInAppImpression(CommunicationTypes.NATIVE_AD, nativeAd)
}

fun trackClick(nativeAd: EMMANativeAd) {
    EMMA.getInstance().sendInAppClick(CommunicationTypes.NATIVE_AD, nativeAd)
}

```
  </Step>
  <Step 
  title="MainActivity ‚Äì Integraci√≥n de Native Ads
  ">
Esta actividad conecta con `NativeAdManager` para gestionar los anuncios nativos.

  ```kotlin title="MainActivity.kt"
private fun loadNativeAd() {
        val templateId = "native-ad-kotlin"
        val adManager = NativeAdManager(this, nativeAdContainer)
        adManager.loadNativeAd(templateId)
    }

    private fun loadNativeAdBatch() {
        val templateId = "native-ad-kotlin"
        val adManager = NativeAdManager(this, nativeAdContainer)
        adManager.loadNativeAdBatch(templateId)
    }
``` 
</Step>
</Steps>

## StartView
La StartView es un formato de comunicaci√≥n que te permite mostrar un contenido HTML, alojado en una URL, en un WebView a pantalla completa.
 ```kotlin title="StartView"
fun getStartView() {
  val startViewRequest = EMMAInAppRequest(EMMACampaign.Type.STARTVIEW)
  EMMA.getInstance().getInAppMessage(startViewRequest)
}
``` 

## AdBall
El AdBall es una peque√±a vista circular que muestra una imagen. Esta vista se puede arrastrar por toda la pantalla y eliminar de ella en cualquier momento, contiene un CTA que es una URL con contenido HTML que lanza un WebView al hacer clic en la ella.


 ```kotlin title="AdBall"
fun getAdBall() {
  val adBallRequest = EMMAInAppRequest(EMMACampaign.Type.ADBALL)
  EMMA.getInstance().getInAppMessage(adBallRequest)
}
``` 
## Banner
El banner es un formato de comunicaci√≥n que permite adaptar una imagen o GIF en formato banner dentro de una pantalla de la aplicaci√≥n. Este banner se puede mostrar en el de la pantalla d√≥nde se muestra o en el botom de esta. El banner contiene un CTA configurable en el Dashboard de EMMA y puede ser un deeplink o una URL https. En el caso de ser la segunda opci√≥n, al hacer hacer clic se abre un WebView con el contenido de la URL.

<Info>Se recomienda hacer la llamada despu√©s de que todos los elementos de la pantalla est√©n cargados.</Info>

 ```kotlin title="Banner"
fun getBanner() {
  val bannerRequest = EMMAInAppRequest(EMMACampaign.Type.BANNER)
  EMMA.getInstance().getInAppMessage(bannerRequest);
}
``` 

## Strip
El strip te permite mostrar un banner en lo alto de la pantalla del dispositivo con un texto que va pasando a modo de carrusel. Variables como el tiempo de duraci√≥n de la rotaci√≥n o el tiempo de visualizaci√≥n son configurables desde el Dashboard.


 ```kotlin title="Strip"
fun getStrip() {
  val stripRequest = EMMAInAppRequest(EMMACampaign.Type.STRIP)
  EMMA.getInstance().getInAppMessage(stripRequest);
}
``` 

## Coupon

EMMA Coupons te permite obtener, verificar y canjear cupones que se hayan definido y configurado en la plataforma de EMMA. 
Para crear un cup√≥n en la plataforma EMMA puedes ver [este ](https://docs.emma.io/es/mensajes-inapp#cup%C3%B3n) tutorial.

  <Steps>
  <Step 
  title="Data - CouponDataSource.kt
 ">

  Esta clase implementa la fuente de datos para los Coupones. Forma parte de la **capa de datos** de la arquitectura y se comunica directamente con el SDK de EMMA ¬¥(EMMA.getInstance())¬¥. Gestiona todas las operaciones relacionadas con cupones;
  Obtenci√≥n de cupones, Redenci√≥n de cupones, Cancelaci√≥n, Consulta de redenciones v√°lidas

 
  ```kotlin title="CouponDataSource.kt"
  class CouponDataSource : CouponDataSourceInterface, EMMACouponsInterface {
    private var couponsCallback: ((List<EMMACoupon>) -> Unit)? = null
    private var redemptionCallback: ((Boolean) -> Unit)? = null
    private var cancelCallback: ((Boolean) -> Unit)? = null
    private var redeemCountCallback: ((Int) -> Unit)? = null

    override fun getCoupons(callback: (List<EMMACoupon>) -> Unit) {
    }

    override fun redeemCoupon(couponId: String, callback: (Boolean) -> Unit) {
    }

    override fun cancelCoupon(couponId: String, callback: (Boolean) -> Unit) {
    }

    override fun getCouponRedeemCount(couponId: String, callback: (Int) -> Unit) {
    }

    override fun onCouponsReceived(coupons: List<EMMACoupon>) {
    }

    override fun onCouponsFailure() {
    }

    override fun onCouponRedemption(success: Boolean) {
    }

    override fun onCouponCancelled(success: Boolean) {
    }

    override fun onCouponValidRedeemsReceived(numRedeems: Int) {
    }
}

```
<Info>[Aqu√≠](https://developer.emma.io/es/android/integracion-sdk#coupon) el ejemplo de la documentaci√≥n oficial</Info>
  </Step>

    <Step 
  title="Interface - CouponDataSourceInterface.kt
  ">

 Crear interface que act√∫e como puente entre la UI/ViewModel y la capa de datos **(CouponDataSource)**

  ```kotlin title="CouponDataSourceInterface.kt"
  interface CouponDataSourceInterface {
    fun getCoupons(callback: (List<EMMACoupon>) -> Unit)
    fun redeemCoupon(couponId: String, callback: (Boolean) -> Unit)
    fun cancelCoupon(couponId: String, callback: (Boolean) -> Unit)
    fun getCouponRedeemCount(couponId: String, callback: (Int) -> Unit)
}

```
  </Step>
    <Step 
  title="Repositorio - CouponRepository.kt
  ">

  Delega el acceso a los datos al dataSource (que implementa la interfaz).

  ```kotlin title="CouponRepository.kt"
  class CouponRepository(private val dataSource: CouponDataSourceInterface) {
    fun getCoupons(callback: (List<EMMACoupon>) -> Unit) {
        dataSource.getCoupons(callback)
    }

    fun redeemCoupon(couponId: String, callback: (Boolean) -> Unit) {
        dataSource.redeemCoupon(couponId, callback)
    }
}

```
  </Step>

    <Step 
  title="UI - CouponManager.kt
  ">
  Esta clase transforma los datos del cup√≥n en vistas visibles dentro de un LinearLayout. Utiliza LayoutInflater para inflar la vista desde XML, asigna los textos y configura la acci√≥n del bot√≥n para redimir.

  ```kotlin title="CouponManager.kt"
  
class CouponManager(
    private val context: Context,
    private val container: LinearLayout 
) {
    private val repository = CouponRepository(CouponDataSource())
    }
 
    private fun renderCoupon(coupon: EMMACoupon) {
    }

    private fun redeemCoupon(coupon: EMMACoupon) {   
    }

```
  </Step>

  <Step 
  title="Carga y renderizado del c√∫pon
   ">

  Cuando se llama a **loadCoupons()**, se limpian primero todas las vistas dentro del contenedor. Luego, se consulta el repositorio para obtener los cupones, y por cada uno se ejecuta **renderCoupon()** para mostrarlo visualmente.
  El m√©todo **renderCoupon()** infla una vista desde el layout XML, coloca los datos del cup√≥n (t√≠tulo y descripci√≥n) y configura un bot√≥n para redimirlo.
 
  ```kotlin title="CouponManager.kt"
  fun loadCoupons() {
    container.removeAllViews()
    repository.getCoupons { coupons ->
        coupons.forEach { renderCoupon(it) }
    }
}
private fun renderCoupon(coupon: EMMACoupon) {
    val view = LayoutInflater.from(context).inflate(R.layout.view_coupon_item, container, false)

    view.findViewById<TextView>(R.id.tv_coupon_title).text = coupon.title
    view.findViewById<TextView>(R.id.tv_coupon_description).text = coupon.description

    view.findViewById<Button>(R.id.btn_redeem).setOnClickListener {
        redeemCoupon(coupon)
    }

    container.addView(view)
}
```
  </Step>
 <Step 
  title="Redenci√≥n de cupones
   ">

Cuando un usuario presiona el bot√≥n de redenci√≥n, se llama a redeemCoupon(coupon). Este m√©todo env√≠a la solicitud de redenci√≥n al CouponRepository, y si es exitosa, se recarga la lista de cupones.
 
  ```kotlin title="CouponManager.kt"
 private fun redeemCoupon(coupon: EMMACoupon) {
    val couponIdString = coupon.couponId.toString()

    repository.redeemCoupon(couponIdString) { success ->
        Toast.makeText(
            context,
            if (success) "Cup√≥n canjeado!" else "Error al canjear",
            Toast.LENGTH_SHORT
        ).show()

        if (success) {
            container.removeAllViews()
            loadCoupons()
        }
    }
}
```
  </Step>

  
  <Step 
  title="MainActivity - Integraci√≥n de Coupon
  ">
  Esta actividad conecta con CouponManager para gestionar los anuncios nativos.
  ```kotlin title="MainActivity.kts"
class MainActivity : AppCompatActivity(), EmmaPluginCallback {
    private lateinit var couponContainer: LinearLayout
    private lateinit var couponManager: CouponManager

    private fun setupViews() {
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }

        couponContainer = findViewById(R.id.coupon_container)
        couponManager = CouponManager(this, couponContainer)
        couponManager.loadCoupons()
    }
}
```
</Step>

    </Steps>

## Plugins personalizados

A partir de la versi√≥n 4.9.0 se ha a√±adido la posibilidad de poder a√±adir plugins in-app al SDK. Los plugins in-app funcionan a trav√©s de la tecnolog√≠a de NativeAd.


<Steps>
<Step 
  title="Data - CustomEmmaPlugin.kts
  ">

Puedes crear tu propio formato de comunicaci√≥n y convertirlo en un plugin in-app, para ello es necesario que la clase principal del nuevo formato extienda de la clase abstracta **EMMAInAppPlugin**, esta clase obliga a sobrescribir dos m√©todos; **show()** y **dismiss()**.

  ```kotlin title="CustomEmmaPlugin.kts"
  class CustomEmmaPlugin : EMMAInAppPlugin() {

    private var callback: EmmaPluginCallback? = null

    companion object {
        private const val TAG = "CustomEmmaPlugin"
        private const val FIELD_TITLE = "Title"
        private const val FIELD_BODY = "Body"
        private const val FIELD_CUSTOM = "custom"
    }

    fun setPluginCallback(callback: EmmaPluginCallback) {
    }
    override fun getId(): String = "emma-plugin-test-plugin"

    override fun show(context: Activity?, nativeAd: EMMANativeAd) {
        context?.let { activity ->
            try {
                val pluginData = extractPluginData(nativeAd)
                callback?.onEmmaPluginLoaded(pluginData)
                sendImpression(nativeAd) // Informa a EMMA que el plugin fue mostrado
                invokeShownListeners(nativeAd)
            } catch (e: Exception) {
                val errorMessage = "Error en plugin: ${e.message}"
                Log.e(TAG, errorMessage)
                callback?.onEmmaPluginError(errorMessage)
            }
        } ?: run {
            callback?.onEmmaPluginError("Contexto nulo en show()")
        }
    }

    private fun extractPluginData(nativeAd: EMMANativeAd): EmmaPluginData {
    }

    fun handleClick(pluginData: EmmaPluginData) {
    }

    override fun dismiss() {
        callback?.onEmmaPluginClosed()
    }
}

```

<Info>[Aqu√≠](https://developer.emma.io/es/android/integracion-sdk#plugins-personalizados) el ejemplo de la documentaci√≥n oficial y puedes entrar a [este](https://github.com/EMMADevelopment/inapp-plugin-prism-android) link para ver un Pluging de ejemplo</Info>

</Step>
<Step 
  title="Data - EmmaPluginData.kts"
>
Clase de datos que contiene la informaci√≥n que ser√° entregada por el plugin una vez cargado. Esta informaci√≥n puede ser usada para renderizar vistas o mostrar contenido personalizado al usuario.

```kotlin title="EmmaPluginData.kts"
class EmmaPluginData(
    val title: String,
    val body: String,
    val custom: String
)
```
</Step>

<Step 
  title="Sealed Class - EmmaPluginState.kts
  ">
Clase sellada que representa los diferentes estados posibles del plugin. Es √∫til para manejar el flujo de estados

  ```kotlin title="EmmaPluginState.kts"
sealed class EmmaPluginState {
    object Loading : EmmaPluginState()
    data class Success(val data: EmmaPluginData) : EmmaPluginState()
    data class Error(val message: String) : EmmaPluginState()
    object Closed : EmmaPluginState()
}
```
</Step>

<Step 
  title="UI - EmmaPluginViewModel.kts
  ">

Clase que implementa la interfaz **EmmaPluginCallback** y expone el estado del plugin mediante un **LiveData**, permitiendo que la capa de UI observe los cambios y actualice su contenido en funci√≥n del estado actual.

  ```kotlin title="EmmaPluginViewModel.kts"
class EmmaPluginViewModel : ViewModel(), EmmaPluginCallback {

    private val _pluginState = MutableLiveData<EmmaPluginState>()
    val pluginState: LiveData<EmmaPluginState> = _pluginState

    override fun onEmmaPluginLoaded(pluginData: EmmaPluginData) {
        _pluginState.value = EmmaPluginState.Success(pluginData)
    }

    override fun onEmmaPluginError(error: String) {
        _pluginState.value = EmmaPluginState.Error(error)
    }

    override fun onEmmaPluginClosed() {
        _pluginState.value = EmmaPluginState.Closed
    }

    override fun onEmmaPluginClicked(pluginData: EmmaPluginData) {
        // Puedes manejar acciones personalizadas aqu√≠ si es necesario
    }
}
 ```
</Step>

<Step 
  title="UI - PluginRenderer.kts
  ">
 
Clase encargada de **renderizar visualmente** el contenido del plugin en pantalla. Toma los datos **EmmaPluginData** y los inserta dentro de un contenedor **FrameLayout** inflando un layout XML.


  ```kotlin title="PluginRenderer.kts"
  class PluginRenderer(
    private val context: Context,
    private val container: FrameLayout
) {

    fun render(data: EmmaPluginData, onClick: (() -> Unit)? = null) {
        Log.d("PluginRenderer", "Renderizando plugin con t√≠tulo: ${data.title}")

        // Limpia el contenedor
        container.removeAllViews()

        // Infla el layout sin adjuntarlo inmediatamente
        val view: View = LayoutInflater.from(context)
            .inflate(R.layout.emma_plugin_container, container, false)

        // Asigna los textos recibidos
        view.findViewById<TextView>(R.id.plugin_title)?.text = data.title
        view.findViewById<TextView>(R.id.plugin_body)?.text = data.body
        view.findViewById<TextView>(R.id.plugin_custom)?.text = data.custom

        // Configura el bot√≥n de acci√≥n
        view.findViewById<Button>(R.id.plugin_action_button)?.setOnClickListener {
            Log.d("PluginRenderer", "Bot√≥n del plugin clickeado")
            onClick?.invoke()
        }

        container.addView(view)
        container.visibility = View.VISIBLE
        container.requestLayout()
        container.invalidate()
    }
}
```
</Step>

<Step 
  title=" MainActivity
  ">
Esta actividad conecta con **CustomEmmaPlugin** para mostrar y gestionar el contenido din√°mico que proviene del SDK de EMMA. 

Se integra con el **EmmaPluginViewModel** para observar los cambios de estado del plugin (carga, error, cierre, clic), y renderiza la interfaz del plugin utilizando la clase **PluginRenderer**.

  ```kotlin title=" MainActivity.kts"
  class MainActivity : AppCompatActivity(), EmmaPluginCallback {

    private lateinit var customEmmaPlugin: CustomEmmaPlugin
    private val emmaPluginViewModel: EmmaPluginViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        setupEmmaPlugin()
        observePluginStates()

        findViewById<View>(R.id.btn_test_plugin).setOnClickListener {
            Toast.makeText(this, "Probando plugin de EMMA...", Toast.LENGTH_SHORT).show()

            val request = EMMANativeAdRequest().apply {
                templateId = customEmmaPlugin.id
            }

            try {
                EMMA.getInstance().getInAppMessage(request)
            } catch (e: Exception) {
                emmaPluginViewModel.onEmmaPluginError("Error al cargar el plugin: ${e.message}")
            }
        }
    }

    private fun setupEmmaPlugin() {
        customEmmaPlugin = CustomEmmaPlugin().apply {
            setPluginCallback(this@MainActivity)
        }
    }

    override fun onEmmaPluginLoaded(pluginData: EmmaPluginData) {
        emmaPluginViewModel.onEmmaPluginLoaded(pluginData)
    }

    override fun onEmmaPluginError(error: String) {
        emmaPluginViewModel.onEmmaPluginError(error)
    }

    override fun onEmmaPluginClosed() {
        emmaPluginViewModel.onEmmaPluginClosed()
    }

    override fun onEmmaPluginClicked(pluginData: EmmaPluginData) {
        Toast.makeText(this, "Plugin clickeado: ${pluginData.title}", Toast.LENGTH_SHORT).show()
    }

    private fun observePluginStates() {
        emmaPluginViewModel.pluginState.observe(this, Observer { state ->
            when (state) {
                is EmmaPluginState.Success -> showPluginData(state.data)
                is EmmaPluginState.Error -> showError(state.message)
                is EmmaPluginState.Closed -> clearPlugin()
                is EmmaPluginState.Loading -> showLoading()
            }
        })
    }

    private fun showPluginData(pluginData: EmmaPluginData) {
        val pluginContainer = findViewById<FrameLayout>(R.id.emma_plugin_container)
        pluginContainer.visibility = View.VISIBLE

        val renderer = PluginRenderer(this, pluginContainer)
        renderer.render(pluginData) {
            Toast.makeText(this, "Plugin clickeado: ${pluginData.title}", Toast.LENGTH_SHORT).show()
            customEmmaPlugin.handleClick(pluginData)
        }
    }

    private fun clearPlugin() {
        val pluginContainer = findViewById<FrameLayout>(R.id.emma_plugin_container)
        pluginContainer.removeAllViews()
        Toast.makeText(this, "Plugin cerrado", Toast.LENGTH_SHORT).show()
    }

    private fun showError(message: String) {
        Toast.makeText(this, "Error: $message", Toast.LENGTH_SHORT).show()
    }

    private fun showLoading() {
        Toast.makeText(this, "Cargando plugin...", Toast.LENGTH_SHORT).show()
    }
}
```
</Step>

<Step 
  title="Data - ExampleApplication.kts
  ">

Para integrar un plugin es necesario a√±adirlo en el sdk despu√©s del inicio de sesi√≥n, para ello es necesario utilizar el m√©todo addInAppPlugin.

```kotlin title="ExampleApplication.kts"
import android.app.Application
import io.emma.android.EMMA

class ExampleApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        val configuration = EMMA.Configuration.Builder(this)
            .setSessionKey("TU_SESION_KEY")
            .trackScreenEvents(false)
            .setDebugActive(BuildConfig.DEBUG)
            .build()

        EMMA.getInstance().startSession(configuration)
        EMMA.getInstance().addInAppPlugins(CustomEmmaPlugin()) // [!code focus]
    }
}
```
</Step>
</Steps>

